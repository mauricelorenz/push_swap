*This project has been created as part of the 42 curriculum by mlorenz.*

# Description

This project aims to teach the understanding of sorting algorithms by sorting a stack of unique integer values with a limited set of instructions.
The to-be-sorted values are passed to the program as command line arguments. Next the input gets validated by checking if all arguments are 32 bit integers.
After validation the values get parsed, in case of this implementation into a singly linked list forming stack a.
The additional stack b, used for performing some of the following operations is empty at start and has to be empty at the end of the program execution.

The implemented sorting algorithms work the following way if the list is not already sorted:

1. If there are only two values they get swapped in place (sa).
2. sort_tiny(): If there are three values a simple algorithm is used on stack a.
3. sort_small(): Pushes up to two of the smallest values to stack b (pb), calls sort_tiny() on stack a and pushes back from stack b (pa).
4. sort_big(): Iterates over stack a and decides by a stack size related range if the value gets pushed to the top of b (pb) or to the bottom of b (pb + rb). Values outside of the range are temporarily skipped by rotating stack a (ra). It pushes the values back (pa) after rotating or reverse rotating stack b (rb/rrb) to get the desired value to the top depending on its position in the stack.

## Requirements

For maximum project validation:

- Use at most 700 operations for a stack size of 100
- Use at most 5500 operations for a stack size of 500

## Operations

| Operation | Description |
|-----------|-------------|
| sa/sb/ss | swap the first two elements of stack a, stack b or both stacks |
| pa/pb | pop the top element of one stack and push it on top of the named stack |
| ra/rb/rr | rotate the named stack/s upward by one with the first element becoming the last one |
| rra/rrb/rrr | rotate the named stack/s downward by one with the last element becoming the first one |

## Bonus

The bonus part of this project is a program called checker.
It verifies that:

- The passed numbers are valid
- The output contains only valid operations separated by newlines
- After execution, stack a is sorted and stack b is empty

# Instructions

## Compilation

Use
`make` or `make push_swap`
to build the program.

Use
`make bonus`
to build the checker.

To delete the object files use
`make clean` or `make fclean`
to also remove archive files and executables.

To rebuild the program entirely use
`make re`.

## Execution

Execute the program by calling
`./push_swap [ARGS]`.

### Example
```bash
$ ./push_swap 2 5 3 4 1
rra
pb
pb
ra
pa
pa
```

On Linux/macOS to easily check the amount of executed operations use
`./push_swap [ARGS] | wc -l`.

### Example
```bash
$ ./push_swap 2 5 3 4 1 | wc -l 
6
```

To verify the result use
`./push_swap [ARGS] | ./checker [ARGS]`

### Example
```bash
$ ./push_swap 2 5 3 4 1 | ./checker 2 5 3 4 1
OK
```

## Program behavior

- Return nothing if no arguments are passed or the arguments are already sorted.
- Return `Error` if invalid arguments are passed. E. g. `./push_swap 1 two 3.5 -2147483649`.
- Else return the executed operations.

### Bonus

- Return `Error` for either faulty numbers or operations.
- Return `OK` if stack a is sorted and stack b is empty.
- Else return `KO`.

# Resources

## References

[asioud's push_swap implementation](https://github.com/AzerSD/ksort-push_swap) was used for inspiration and comparison.

## AI Usage

In my project implementation the use of AI was limited to:

- discussing general implementation
- minor details, like the naming of variables
- proofreading commit messages and this README

Not a single line of code was generated by AI.